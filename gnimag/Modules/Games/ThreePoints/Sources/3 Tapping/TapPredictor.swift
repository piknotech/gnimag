//
//  Created by David Knothe on 15.03.21.
//  Copyright Â© 2019 - 2021 Piknotech. All rights reserved.
//

import GameKit
import Image
import Tapping

/// TapPredictor is the main class dealing with tap prediction and scheduling.
final class TapPredictor: TapPredictorBase {
    private let playfield: Playfield
    private let gameModel: GameModel
    private let delay: Double = 0.15 // remove

    /// All active tap monitors, i.e. all taps which have been performed, but are not yet visible for image analysis.
    /// A monitor is removed either when the tap is seen to have been executed or when it is not detected until the monitor's trigger time. In this case, a fresh tap will be executed.
    var monitors = [TapMonitor]()

    /// Default initializer.
    init(playfield: Playfield, tapper: SomewhereTapper, timeProvider: TimeProvider, gameModel: GameModel) {
        self.playfield = playfield
        self.gameModel = gameModel
        super.init(tapper: tapper, timeProvider: timeProvider, tapDelayTolerance: .absolute(0.2))
    }

    /// Analyze the game model to schedule taps.
    /// Instead of using the current time, input+output delay is added.
    override func predictionLogic() -> AbsoluteTapSequence? {
        updateMonitors()
        print(howManyTaps())
        return nil
    }

    /// Update monitors: remove monitors which have been fulfilled or not fulfilled.
    /// Removing a monitor whose tap has not been detected by the phone will trigger a new tap to be generated by predictionLogic.
    func updateMonitors() {
    }

    /// Calculate, given the situation in the game model and the imageProvider's current time, how often the screen should be tapped *right now* (considering in+out delay) in order to rotate to the correct color.
    func howManyTaps() -> Int {
        let realTime = timeProvider.currentTime
        let delay = self.delay
        let currentTime = realTime + delay

        // Convert DotTrackers into DotProperties
        let dots = gameModel.dots
            .compactMap { DotProperties(playfield: playfield, tracker: $0, currentTime: currentTime) }
            .filter { $0.collisionWithPrism > 0 }
            .sorted(by: \.collisionWithPrism)

        guard let firstDot = dots.first,
            let prism = prismColor(at: currentTime) else { return 0 }
        
        return prism.distance(to: firstDot.color)
    }

    /// The color the prism should have at a given future time, considering executed taps.
    private func prismColor(at time: Double) -> DotColor? {
        guard var color = gameModel.prism.state?.topColor else { return nil }

        // Add not-yet-detected taps to the onscreen prism state
        for tap in monitors where tap.tap.performedAt + delay <= time {
            color = color.next
        }

        return color
    }
}

/// Each TapMonitor corresponds to a single tap and monitors whether it has actually been executed.
struct TapMonitor {
    let tap: PerformedTap

    /// If the tap hasn't been detected until this time, the tap monitor will regard this tap as not executed.
    let triggerTime: Double
}
