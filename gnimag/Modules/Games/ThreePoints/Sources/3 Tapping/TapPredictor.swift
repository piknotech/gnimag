//
//  Created by David Knothe on 15.03.21.
//  Copyright Â© 2019 - 2021 Piknotech. All rights reserved.
//

import Common
import GameKit
import Image
import Tapping

/// TapPredictor is the main class dealing with tap prediction and scheduling.
final class TapPredictor: TapPredictorBase {
    private let playfield: Playfield
    private let gameModel: GameModel
    private let delay: Double = 0.13 // remove

    private let triggerDuration = 0.2

    /// `Distances` describes preferred minimum distances between consecutive events.
    /// Tap scheduling tries keeping these distances, and generates a fair solution if this cannot be done.
    private struct Distances {
        static let betweenTaps = 0.1
        static let afterCollision = 0.1
        static let beforeCollision = 0.1
    }

    /// All active tap tokens, i.e. all taps which have been performed, but are not yet visible for image analysis.
    /// A token is removed either when the tap is seen to have been executed or when it is not detected until the token's trigger time. In this case, a fresh tap will be executed.
    private var tokens = [TapToken]()

    /// The most recent events. Only the most recent one is relevant currently.
    private var pastEvents = FixedSizeFIFO<Event>(capacity: 2)

    /// Default initializer.
    init(playfield: Playfield, tapper: SomewhereTapper, timeProvider: TimeProvider, gameModel: GameModel) {
        self.playfield = playfield
        self.gameModel = gameModel

        super.init(tapper: tapper, timeProvider: timeProvider, tapDelayTolerance: .absolute(0.2))

        scheduler.tapPerformed.subscribe(tapPerformed(tap:))
    }

    /// Analyze the game model to schedule taps.
    /// Instead of using the current time, input+output delay is added.
    override func predictionLogic() -> AbsoluteTapSequence? {
        let previousSequence = tapSequence
        guard gameModel.prism.topColor != .unsure else { return previousSequence }

        let realTime = timeProvider.currentTime
        let currentTime = realTime + delay
        updateTokens(realTime: realTime)

        // Get next collision
        let collision = nextCollisionWithDot(currentTime: currentTime)
        currentCollisionWithDot = collision

        // Get required number of taps to survive next collision
        guard let nextCollision = collision, let prismColor = prismColor else { return nil }
        let T = nextCollision.absoluteTime - currentTime
        let numTaps = prismColor.distance(to: nextCollision.dotColor)
        if numTaps == 0 { return nil }

        // Keep distance to most recent event
        let mostRecentPastEvent = pastEvents.elements.max(by: \.absoluteTime)
        let distanceToLastEvent = currentTime - (mostRecentPastEvent?.absoluteTime ?? .greatestFiniteMagnitude)

        // Calculate preferred safety net, i.e. distance to most recent event
        var safetyNet: Double = 0
        if mostRecentPastEvent is CollisionWithDot {
            safetyNet = max(0, Distances.afterCollision - distanceToLastEvent)
        } else if mostRecentPastEvent is PrismRotation {
            safetyNet = max(0, Distances.betweenTaps - distanceToLastEvent)
        }

        // Calculate total forces from left and from right; find a fair center point of the opposite-directed arrows if they overlap
        let rightForce = safetyNet + Double(numTaps - 1) * Distances.betweenTaps
        let leftForce = Distances.beforeCollision

        var newRightForce = rightForce
        if rightForce + leftForce > T {
            let overlap = rightForce + leftForce - T
            newRightForce -= overlap / 2
            newRightForce = min(T, max(0, newRightForce))
        }
        let factor = rightForce == 0 ? 0 : newRightForce / rightForce

        // Generate tap sequence
        let distances: [Double] = Array(0 ..< numTaps).map { (i: Int) -> Double in
            factor * (safetyNet + Double(i) * Distances.betweenTaps)
        }

        let relative = RelativeTapSequence(taps: distances.map(RelativeTap.init(scheduledIn:)), unlockDuration: nil)
        return AbsoluteTapSequence(relative, relativeTo: timeProvider.currentTime)
    }

    /// Update tokens: remove tokens which have been fulfilled or not fulfilled.
    /// Removing a token whose tap has not been detected by the smartphone will trigger a new tap to be generated by predictionLogic.
    private func updateTokens(realTime: Double) {
        if case .color(let color) = gameModel.prism.mostRecentChange, !tokens.isEmpty {
            // Remove as many monitors as possible (longest prefix)
            if let removeUntil = (tokens.lastIndex { $0.color == color }) {
                tokens.removeFirst(removeUntil + 1)
            }
        }

        // Remove tokens for executed taps which have not been detected yet
        tokens.removeAll { realTime > $0.triggerTime }
    }

    /// The color the prism should have after all already-executed taps have been detected.
    /// During `unsure` state of the prism, this is `nil`, and tap prediction is paused.
    private var prismColor: DotColor? {
        guard case .color(var color) = gameModel.prism.topColor else { return nil }

        // Consider all tokens: taps that have been executed but are not yet visible
        for _ in tokens { color = color.next }

        return color
    }

    /// Called after a tap was performed by the scheduler.
    private func tapPerformed(tap: PerformedTap) {
        let token = TapToken(tap: tap, color: prismColor!.next, triggerTime: tap.performedAt + delay + triggerDuration)
        tokens.append(token)

        let event = PrismRotation(absoluteTime: tap.performedAt + delay)
        pastEvents.append(event)
    }

    /// Calculate the next collision with a dot.
    private func nextCollisionWithDot(currentTime: Double) -> CollisionWithDot? {
        gameModel.dots
            .compactMap { CollisionWithDot(playfield: playfield, tracker: $0) }
            .filter { $0.absoluteTime > currentTime }
            .min(by: \.absoluteTime)
    }

    /// When `currentCollisionWithDot` is changed, the old collisionWithDot will be added to the event stream.
    private var currentCollisionWithDot: CollisionWithDot? {
        willSet {
            if let old = currentCollisionWithDot, old.tracker != newValue?.tracker {
                pastEvents.append(old)
            }
        }
    }
}

/// Each TapToken represents a single tap which has been executed, but not yet detected by image analysis.
struct TapToken {
    let tap: PerformedTap

    /// The color which will be on top after this tap.
    let color: DotColor

    /// If the tap hasn't been detected until this time, the TapPredictor will regard this tap as not executed. Then, the tap will be executed again.
    let triggerTime: Double
}
